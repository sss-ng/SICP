## 1.1 - The Elements of Programming

### Exercise 1.1.1

```scheme
> 10
10
> (+ 5 3 4)
12
> (- 9 1)
8
> (/ 6 2)
3
> (+ (* 2 4) (- 4 6))
6
> (define a 3)
> (define b (+ a 1))
> b
4
> (+ a b (* a b))
19
> (= a b)
#f
> (if (and (> b a) (< b (* a b)))
      b
      a)
4
> (cond ((= a 4) 6)
        ((= b 4) (+ 6 7 a))
        (else 25))
16
```

### Exercise 1.1.2

```scheme
#lang sicp

(/
 (+ 5 4 (- 2
           (- 3
              (+ 6
                 (/ 4 5)))))
 (* 3
    (- 6 2)
    (- 2 7)))
```

### Exercise 1.1.3

```scheme
#lang sicp

(define (sum-square-larger a b c)
  (cond ((< a b)
          (if (< a c)
             (+ (* b b) (* c c))   ;; a is smallest
             (+ (* b b) (* a a)))) ;; c is smallest
        (else
          (if (< b c)
             (+ (* a a) (* c c))   ;; b is smallest
             (+ (* b b) (* a a)))) ;; c is smallest
        ))

(sum-square-larger 1 2 3)
;; 13
(sum-square-larger 1 3 2)
;; 13
(sum-square-larger 2 1 3)
;; 13
(sum-square-larger 2 3 1)
;; 13
(sum-square-larger 3 1 2)
;; 13
(sum-square-larger 3 2 1)
;; 13
```

A slightly cleaner version assuming we have `<=`:

```scheme
#lang sicp

(define (square x)
  (* x x))

(define (sum-square a b)
  (+ (square a) (square b)))

(define (sum-square-larger a b c)
  (cond ((and (<= a b) (<= a c)) ;; a is the min of a, b, c
         (sum-square b c))
        ((and (<= b a) (<= b c)) ;; b is the min of a, b, c
         (sum-square a c))
        (else                    ;; c is the min of a, b, c
         (sum-square a b))))
```

### Exercise 1.1.4

```scheme
(define (a-plus-abs-b a b)
  ((if (> b 0) + -) a b))
```

The above returns `+` or `-` depending if `b` is positive or negative. Then this primitive is applied to `a` and `b`.

### Exercise 1.1.5

```scheme
(define (p) (p))

(define (test x y)
  (if (= x 0)
      0
      y))

(test 0 (p))
```

With `applicative-order` evaluation, Ben will get an infinite loop that will eventually cause the process to error. This is because the parameters of the procedure call will be evaluated first, leading to the execution of the recursive procedure `p` without a base case.

When using `normal-order` evaluation, a value will be returned: `0`. This is because normal-order evaluation will 'fully expand, then reduce' parameters in a procedure. Therefore, the ill conditioned procedure `p` is never called, since the control flow of the procedure bypasses it entirely.

### Exercise 1.1.6

`Scheme` uses applicative order evaluation. That is, a procedure's parameters are evaluated before the actual procedure is. So, in this case, rewriting `if` as a procedure will cause the process to recurse infinitely - which will cause it to crash.

### Exercise 1.1.7

```scheme
# lang sicp

(define (sqrt-iter guess prev-guess x)
  (if (good-enough? guess prev-guess)
      guess
      (sqrt-iter (improve guess x) guess x)))

(define (improve guess x)
  (average guess (/ x guess)))

(define (average x y)
  (/ (+ x y) 2))

(define (good-enough? guess prev-guess)
  (< (/ (abs (- prev-guess guess)) prev-guess) 0.001))

(define (sqrt x)
  (sqrt-iter 1.0 2.0 x))
```

Example of error:

```scheme
> (sqrt 0.0000001)
0.03125106561775382
```

We should get something more like 0.000316...
With the new code above, comparing `guess` to `prev-guess`, we do.

### Exercise 1.1.8

Newtons method for cube roots

```scheme
# lang sicp

(define (cube-rt-iter guess prev-guess x)
  (if (good-enough? guess prev-guess)
      guess
      (cube-rt-iter (improve guess x) guess x)))

(define (improve guess x)
  (/
    (+
      (/ x (* guess guess))
      (* 2 guess))
    3))

(define (good-enough? guess prev-guess)
  (< (/ (abs (- prev-guess guess)) prev-guess) 0.001))

(define (cube-rt x)
  (cube-rt-iter 1.0 2.0 x))
```

## 1.2 - Procedures and the Processes They Generate

### Exercise 1.2.9

```scheme
(define (+ a b)
  (if (= a 0) b (inc (+ (dec a) b))))
```

`(+ 4 5)` produces a recursive process:

```
(+ 4 5)
(inc (+ 3 5))
(inc (inc (+ 2 5)))
(inc (inc (inc (+ 1 5))))
(inc (inc (inc (inc (+ 0 5)))))
(inc (inc (inc (inc 5))))
(inc (inc (inc 6)))
(inc (inc 7))
(inc 8)
9
```

and for

```scheme
(define (+ a b)
  (if (= a 0) b (+ (dec a) (inc b))))
```

`(+ 4 5)` produces a linear process:

```
(+ 4 5)
(+ 3 6)
(+ 2 7)
(+ 1 8)
(+ 0 9)
9
```

### Exercise 1.2.10

```scheme
(define (A x y)
  (cond ((= y 0) 0)
    ((= x 0) (* 2 y))
    ((= y 1) 2)
    (else (A (- x 1) (A x (- y 1))))))

(define (f n) (A 0 n))
(define (g n) (A 1 n))
(define (h n) (A 2 n))
(define (k n) (* 5 n n))
```

`(f n)` produces $f(n) = 2n$
`(g n)` produces $g(n) = 2^n $
`(h n)` produces $h(n) = 2^{2^{2 (n-times)}}$

### Exercise 1.2.11

```scheme

#lang sicp

(define (f n)
  (if (< n 3)
      n
      (+
       (f (- n 1))
       (* 2 (f (- n 2)))
       (* 3 (f (- n 3))))))

(define (f2 n)
  (define (f-iter a b c count)
    (if (= count 2)
        a
        (f-iter
          (+ a (* 2 b) (* 3 c))
          a
          b
          (- count 1))))
  (if (< n 3)
      n
      (f-iter 2 1 0 n)))
```

### Exercise 1.2.12

```scheme
#lang sicp


(define (pascal row col)
  (if (or (<= col 1) (= row col) )
      1
      (+ (pascal (- row 1) col) (pascal (- row 1) (- col 1)))
  ))

(pascal 1 1)
(pascal 2 1)
(pascal 2 2)
(pascal 3 1)
(pascal 3 2)
(pascal 3 3)
(pascal 4 1)
(pascal 4 2)
(pascal 4 3)
(pascal 4 4)
```

### Exercise 1.2.13

To prove that $Fib(n)$ is the closest integer to $\phi ^ n / \sqrt{5}$, we will show that $Fib(n) = (\phi ^ n - \psi ^ n)/\sqrt{5}$. This works because $\psi$ is smaller than 1, so to a power it is also less than 1, which shows that Fib(n) is close-ish to $\phi ^ n / \sqrt{5}$.

We will prove this via induction.
Let $P(n)$ be the statement $Fib(n) = (\phi ^ n - \psi ^ n)/\sqrt{5}$.

$P(0)$ and $P(1)$ are obviously true by arithmetic.
Now lets assume that $P(k)$ is true for some $k$. We want to show $P(k+1)$ is also true.

Lets consider $P(k+1)$: $Fib(k+1) = (\phi ^ {k+1} - \psi ^ {k+1})/\sqrt{5}$

We know that

$Fib(k+1)$

$$
= Fib(k) + Fib(k-1)
=  (\phi ^ {k} - \psi ^ {k}) / \sqrt{5} + (\phi ^ {k-1} - \psi ^ {k-1}) / \sqrt{5} \\

=  ((\phi + 1) \phi ^ {k-1} - (\psi + 1) \psi ^ {k-1}) / \sqrt{5}\\


=  ((\phi ^ 2) \phi ^ {k-1} - (\psi ^ 2) \psi ^ {k-1}) / \sqrt{5}  \;\;\;\;(Note: 1)\\
=  (\phi ^ {k+1} - \psi ^ {k+1}) / \sqrt{5}
$$

$(Note: 1)$ The definition of $\phi$ and $\psi$ is that they are solutions to the equation $x^2 = x+1$.

$\square$
